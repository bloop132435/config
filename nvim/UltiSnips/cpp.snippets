# Generic Snippets
extends c

snippet struct "struct skeleton" Abt
struct $1 {
	$2
};
endsnippet

snippet class "class skeleton" Abt
class $1 {
	$2
};
endsnippet

snippet loc "only execute on local machine" Abt
#ifdef LOCAL
$1
#endif
endsnippet

snippet foe "for each loop" Abt
for(${1:auto} ${2:i} : ${3:container}) {
	$4
}
endsnippet
snippet def "function definition skeleton"
// NOTE: ${4:description}
${1:return type} ${2:name}(${3:parameters});
endsnippet

snippet fnc "function skeleton" Abt
${1:return type} ${2:name}(${3:parameters}) {
	${4}
}
endsnippet

snippet lmb "lambda" iA
[${1:&}](${2:parameters})->${3:return type} {
	${4}
}
endsnippet

global !p
def coutExpand(snip):
	line = snip.buffer[snip.line]
	indent = re.match(r"^\s*",line).group()
	n = int(line.strip())
	snip.buffer[snip.line] = ''
	snp = indent + 'cout<<' + '<<'.join("$" + str(i+1)  for i in range(n)) + "$" + "{" + str(n+1) + ":<<endl};"
	snip.expand_anon(snp)
endglobal

post_jump "coutExpand(snip)"
snippet "cout(\d+)" "multiple cout" rt
`!p snip.rv = match.group(1)`
endsnippet

global !p
def cinExpand(snip):
	line = snip.buffer[snip.line]
	indent = re.match(r"^\s*",line).group()
	n = int(line.strip())
	snip.buffer[snip.line] = ''
	snp = indent + 'cin>>' + '>>'.join("$" + str(i+1) for i in range(n)) + ";"
	snip.expand_anon(snp)
endglobal

post_jump "cinExpand(snip)"
snippet "cin(\d+)" "multiple cin" rt
`!p snip.rv = match.group(1)`
endsnippet


#STL
snippet erm "erase all from container satisfying condition" bt
${1:container}.erase(remove_if(begin($1), end($1),
		${2:condition}
), end($1));
endsnippet

snippet fil "fill container" bt
fill(begin(${1:container}), end($1), ${2:value});
endsnippet

snippet fln "fill n times" bt
fill_n(begin(${1:container}), ${2:count}, ${3:value});
endsnippet

snippet gen "generate over container" bt
generate(begin(${1:container}), end($1),
		${2:genFun}
);
endsnippet

snippet gnn "generate n times" bt
generate_n(begin(${1:container}), ${2:count},
		${3:genFun}
);
endsnippet

snippet iot "ascending fill" bt
iota(begin(${1:container}), end($1), ${2:start});
endsnippet

snippet trn "container 1's transform move to container 2" bt
transform(begin(${1:container1}), end($1),
		begin(${2:container2}),
		${3:conversion}
	);
endsnippet

snippet mod "modify container based on conversion function" bt
transform(begin(${1:container}), end($1), begin($1),
		${2:conversion}
	);
endsnippet

snippet tr2 "transform container 1 and container 2 into container 3" bt
transform(begin(${1:container1}), end($1),
		begin(${2:container2}),
		begin(${3:container3}),
		${4:conversion}
	);
endsnippet


snippet all "all of the container satisfies condition" it
all_of(begin(${1:container}), end($1),
		${2:condition}
);
endsnippet

snippet non "none of" it
none_of(begin(${1:container}), end($1),
		${2:condition}
);
endsnippet

snippet any "any of the container satisfies condition" it
any_of(begin(${1:container}), end($1),
		${2:condition}
);
endsnippet


snippet fin "find if the condition is true" bt
find_if(begin(${1:container}), end($1), $2);
endsnippet

snippet mis "find the first differing element" it
mismatch(begin(${1:container1}), end($1),
		begin(${2:container2}), end($2),
		${3:condition}
	);
endsnippet

snippet count "count all in container filling condition" bt
count_if(begin(${1:container}), end($1),
		${2:condition}
);
endsnippet

snippet inc "if container 2 is a incontinuous subsequence of container 1" it
includes(begin(${1:container}), end($1)
		begin(${2:container}), end($2)${3:
		, comparison}
);
endsnippet


snippet mne "min element" bt
min_element(begin(${1:container}), end($1));
endsnippet

snippet mxe "max element" bt
max_element(begin(${1:container}), end($1));
endsnippet

snippet mme "min and max element" bt
minmax_element(begin(${1:container}), end($1));
endsnippet


snippet acc "accumulate" bt
accumulate(begin(${1:container}), end($1), ${2:starting val});
endsnippet

snippet inp "Inner Product" it
inner_product(begin(${1:container1}), end($1)
			,begin(${2:container2})
			, ${3:initial}
			, ${4:accumulator}
			, ${5:adder}
);
endsnippet


snippet prt "partition" it
partition(begin(${1:container}), end($1),
		${2:condition}
);
endsnippet

snippet stq "quicksort" bt
sort(begin(${1:container}), end($1) $2);
endsnippet

snippet stm "mergesort" bt
stable_sort(begin(${1:container}), end($1) $2);
endsnippet

snippet sth "heapsort" bt
sort_heap(begin(${1:container}), end($1) $2);
endsnippet

snippet isrt "is sorted" bt
is_sorted(begin(${1:container}), end($1) $2);
endsnippet

snippet rev "reverse" bt
reverse(begin(${1:container}), end($1));
endsnippet


snippet bns "binary search" it
binary_search(begin(${1:container}), end($1), ${2:target}${3:, comparison function});
endsnippet

snippet low "lower bound" it
lower_bound(begin(${1:container}), end($1), ${2:target}${3:, comparison function});
endsnippet

snippet upp "upper bound" it
upper_bound(begin(${1:container}), end($1), ${2:target}${3:, comparison function});
endsnippet

snippet cpt "Competitive Programming Template" Abt
#include<bits/stdc++.h>
using namespace std;
$1

int main(int argc, char** argv){
	$0
}
endsnippet

# Algorithms

snippet bfs "breadth first search"
//All in main
// TODO : Modify code to fit your needs
int n; //The number of nodes in the graph
int root; // The starting node
vector<vector<int>> adj; //The adjacency list of the graph
vector<int> dist; //stores the distances of each node from root
dist.resize(-1); //initializes all distance to -1
dist[root] = 0;
queue<int> bfs; //stores the numbers to process in order
bfs.push(root);
while(!bfs.empty()) {
	int cur = bfs.front();
	bfs.pop();
	for(int nex : adj[cur]) { //Finds the next nodes to visit
		if(dist[nex] != -1) {
			continue;
		}
		dist[nex] = dist[cur] + 1;
		bfs.push(nex);
	}
}
endsnippet

snippet dfs "dreadth first search"

//All in main
// TODO : Modify code to fit your needs
int n; //The number of nodes in the graph
int root; // The starting node
vector<vector<int>> adj; //The adjacency list of the graph
vector<int> dist; //stores the distances of each node from root
dist.resize(-1); //initializes all distance to -1
dist[root] = 0;
auto dfs = [&](int pos, auto& dfs_func) -> void {
	for(int nex : adj[pos]) {
		if(dist[nex] != -1) {
			continue;
		}
		dist[nex] = dist[pos] + 1;
		dfs_func(nex, dfs_func);
	}
};
dfs(root, dfs);
endsnippet

snippet ostr "ostream operator overloader for custom structs"
ostream& operator<<(ostream& os, const ${1:struct_name}& object){
	${2:print members}
	return os;
}
endsnippet

# Useful things I type sometimes

snippet .pb "push back" Ai
.push_back($1);$0
endsnippet

# Generic Snippets
snippet for "for loop" t
for(${1:int} ${2:i} = ${3:0};$2${4:<n};$2${5:++}) {
	$6
}
endsnippet

snippet if "if statement" t
if($1) {
	$2
} $0
endsnippet
snippet elif "else if statement" t
else if($1) {
	$2
} $0
endsnippet
snippet else "else statement" t
else {
	$1
}
endsnippet
snippet while "while loop" t
while($1) {
	$2
}$0
endsnippet


global !p
def create_row_placeholders(snip):
	# retrieving single line from current string and treat it like tabstops
	# count
	placeholders_amount = int(snip.buffer[snip.line].split(' ')[-1].split(';')[0])
	line = snip.buffer[snip.line]
	indent = re.match(r"^\s*",line).group()

	# erase current line
	snip.buffer[snip.line] = ''

	# create anonymous snippet with expected content and number of tabstops
	anon_snippet_body = indent + '{' + ', '.join(['$' + str(i+1)
									for i in range(placeholders_amount)]) + '}'

	# expand anonymous snippet
	snip.expand_anon(anon_snippet_body)
endglobal

post_jump "create_row_placeholders(snip)"
snippet "arr(\d+)" "array placeholder" r
`!p snip.rv = match.group(1)`
endsnippet

global !p
import re
def caseCreate(snip):
	line = snip.buffer[snip.line]
	n = int(snip.buffer[snip.line].strip())
	snip.buffer[snip.line] = ''
	indent = re.match(r"^\s*",line).group()
	snippet = indent + "switch($1){\n"
	for i in range(n):
		c = 2 + 2 * i
		b = c + 1
		case = indent + f"case ${c}:\n" + indent + '\t' + f"${b}\n" + indent + '\t' + "break;\n"
		snippet += case
	last = 2 + 2 * n
	snippet += indent + f"default:\n{indent}\t${last}\n{indent}\tbreak;\n"
	snippet +=  indent + '}'
	snip.expand_anon(snippet)
endglobal

post_jump "caseCreate(snip)"
snippet "sw(\d+)" "multiple switch case" r
`!p snip.rv = match.group(1)`
endsnippet


snippet struct "struct skeleton" t
struct $1 {
	$2
};
endsnippet

snippet class "class skeleton" t
class $1 {
	$2
};
endsnippet

snippet loc "only execute on local machine" t
#ifdef LOCAL
${VISUAL}$1
#endif
endsnippet

snippet nloc "only execute on nonlocal machine" t
#ifndef LOCAL
${VISUAL}$1
#endif
endsnippet

snippet foe "for each loop" t
for(${1:auto} ${2:i} : ${3:container}) {
	$4
}
endsnippet
snippet def "function definition skeleton"
// NOTE: ${4:description}
${1:return type} ${2:name}(${3:parameters});
endsnippet

snippet fnc "function skeleton" t
${1:return type} ${2:name}(${3:parameters}) {
	${4}
}
endsnippet

snippet lmb "lambda" i
[${1:&}](${2:parameters})->${3:return type} {
	${4}
}
endsnippet

snippet cmp "comparison lambda" i
[](${1:type} a,$1 b)->bool {
	return ${2:a<b};
}$0
endsnippet

global !p
def coutExpand(snip):
	line = snip.buffer[snip.line]
	indent = re.match(r"^\s*",line).group()
	n = int(line.strip())
	snip.buffer[snip.line] = ''
	snp = indent + 'cout<<' + '<<'.join("$" + str(i+1)  for i in range(n)) + ";"
	snip.expand_anon(snp)
endglobal

post_jump "coutExpand(snip)"
snippet "cout(\d+)" "multiple cout" rt
`!p snip.rv = match.group(1)`
endsnippet

global !p
def cinExpand(snip):
	line = snip.buffer[snip.line]
	indent = re.match(r"^\s*",line).group()
	n = int(line.strip())
	snip.buffer[snip.line] = ''
	snp = indent + 'cin>>' + '>>'.join("$" + str(i+1) for i in range(n)) + ";"
	snip.expand_anon(snp)
endglobal

post_jump "cinExpand(snip)"
snippet "cin(\d+)" "multiple cin" rt
`!p snip.rv = match.group(1)`
endsnippet


#STL
snippet erm "erase all from container satisfying condition" t
${1:container}.erase(remove_if(begin($1), end($1),
		${2:condition}
), end($1));
endsnippet

snippet fil "fill container" t
fill(begin(${1:container}), end($1), ${2:value});
endsnippet

snippet fln "fill n times" t
fill_n(begin(${1:container}), ${2:count}, ${3:value});
endsnippet

snippet gen "generate over container" t
generate(begin(${1:container}), end($1),
		${2:genFun}
);
endsnippet

snippet gnn "generate n times" t
generate_n(begin(${1:container}), ${2:count},
		${3:genFun}
);
endsnippet

snippet iot "ascending fill" t
iota(begin(${1:container}), end($1), ${2:start});
endsnippet

snippet trn "container 1's transform move to container 2" t
transform(begin(${1:container1}), end($1),
		begin(${2:container2}),
		${3:conversion}
	);
endsnippet

snippet mod "modify container based on conversion function" t
transform(begin(${1:container}), end($1), begin($1),
		${2:conversion}
	);
endsnippet

snippet tr2 "transform container 1 and container 2 into container 3" t
transform(begin(${1:container1}), end($1),
		begin(${2:container2}),
		begin(${3:container3}),
		${4:conversion}
	);
endsnippet


snippet all "all of the container satisfies condition" it
all_of(begin(${1:container}), end($1),
		${2:condition}
);
endsnippet

snippet non "none of" it
none_of(begin(${1:container}), end($1),
		${2:condition}
);
endsnippet

snippet any "any of the container satisfies condition" it
any_of(begin(${1:container}), end($1),
		${2:condition}
);
endsnippet


snippet fin "find if the condition is true" t
find_if(begin(${1:container}), end($1), $2);
endsnippet

snippet mis "find the first differing element" it
mismatch(begin(${1:container1}), end($1),
		begin(${2:container2}), end($2),
		${3:condition}
	);
endsnippet

snippet count "count all in container filling condition" t
count_if(begin(${1:container}), end($1),
		${2:condition}
);
endsnippet

snippet inc "if container 2 is a incontinuous subsequence of container 1" it
includes(begin(${1:container}), end($1)
		begin(${2:container}), end($2)${3:
		, comparison}
);
endsnippet


snippet mne "min element" t
min_element(begin(${1:container}), end($1));
endsnippet

snippet mxe "max element" t
max_element(begin(${1:container}), end($1));
endsnippet

snippet mme "min and max element" t
minmax_element(begin(${1:container}), end($1));
endsnippet


snippet acc "accumulate" t
accumulate(begin(${1:container}), end($1), ${2:starting val});
endsnippet

snippet inp "Inner Product" it
inner_product(begin(${1:container1}), end($1)
			,begin(${2:container2})
			, ${3:initial}
			, ${4:accumulator}
			, ${5:adder}
);
endsnippet


snippet prt "partition" it
partition(begin(${1:container}), end($1),
		${2:condition}
);
endsnippet

snippet stq "quicksort" t
sort(begin(${1:container}), end($1) $2);
endsnippet

snippet stm "mergesort" t
stable_sort(begin(${1:container}), end($1) $2);
endsnippet

snippet sth "heapsort" t
sort_heap(begin(${1:container}), end($1) $2);
endsnippet

snippet isrt "is sorted" t
is_sorted(begin(${1:container}), end($1) $2);
endsnippet

snippet rev "reverse" t
reverse(begin(${1:container}), end($1));
endsnippet


snippet bns "binary search" it
binary_search(begin(${1:container}), end($1), ${2:target}${3:, comparison function});
endsnippet

snippet low "lower bound" it
lower_bound(begin(${1:container}), end($1), ${2:target}${3:, comparison function});
endsnippet

snippet upp "upper bound" it
upper_bound(begin(${1:container}), end($1), ${2:target}${3:, comparison function});
endsnippet

snippet cpt "Competitive Programming Template" t
#include <bits/stdc++.h>
using namespace std;
$1

int main(int argc, char** argv){
	$0
}
endsnippet

# Algorithms

snippet bfs "breadth first search"
//All in main
// TODO : Modify code to fit your needs
int n; //The number of nodes in the graph
int root; // The starting node
vector<vector<int>> adj; //The adjacency list of the graph
vector<int> dist; //stores the distances of each node from root
dist.resize(n,-1); //initializes all distance to -1
dist[root] = 0;
queue<int> bfs; //stores the numbers to process in order
bfs.push(root);
while(!bfs.empty()) {
	int cur = bfs.front();
	bfs.pop();
	for(int nex : adj[cur]) { //Finds the next nodes to visit
		if(dist[nex] != -1) {
			continue;
		}
		dist[nex] = dist[cur] + 1;
		bfs.push(nex);
	}
}
endsnippet

snippet dfs "dreadth first search"

//All in main
// TODO : Modify code to fit your needs
int n; //The number of nodes in the graph
int root; // The starting node
vector<vector<int>> adj; //The adjacency list of the graph
vector<int> dist; //stores the distances of each node from root
dist.resize(n,-1); //initializes all distance to -1
dist[root] = 0;
auto dfs = [&](int pos, auto& dfs_func) -> void {
	for(int nex : adj[pos]) {
		if(dist[nex] != -1) {
			continue;
		}
		dist[nex] = dist[pos] + 1;
		dfs_func(nex, dfs_func);
	}
};
dfs(root, dfs);
endsnippet

snippet ostr "ostream operator overloader for custom structs"
ostream& operator<<(ostream& os, const ${1:struct_name}& object){
	${2:print members}
	return os;
}
endsnippet

# Useful things I type sometimes

snippet .pb "push back" i
.push_back($1);$0
endsnippet

snippet .t "top" i
.top();$0
endsnippet

snippet .i "insert"
.insert($1);$0
endsnippet

snippet mp "make pair" i
make_pair($1)
endsnippet

snippet mt "make tuple" i
make_tuple($1)
endsnippet

snippet .f "pair first" i
.first
endsnippet

snippet .s "pair second" i
.second
endsnippet

# Jetbrains style

snippet "(\w+)\.be" "begin and end" ri
`!p snip.rv = "begin(" + match.group(1) + "), end(" + match.group(1) + ")"`
endsnippet

snippet "(\S+)\.for" "for range" ri
for(int ${1:i} = 0;$1 < `!p snip.rv = match.group(1)`;$1++) {
	$2
}
endsnippet

snippet "(\S+)\.fore" "for range less eq" ri
for(int ${1:i} = 0;$1 <= `!p snip.rv = match.group(1)`;$1++) {
	$2
}
endsnippet

snippet "(\S+)\.forr" "reverse for range" ri
for(int ${1:i} = `!p snip.rv = match.group(1)` - 1;$1 >= 0;$1--) {
	$2
}
endsnippet

snippet "(\S+)\.for1" "for range 1 based indexing" ri
for(int ${1:i} = 1;$1 <= `!p snip.rv = match.group(1)`;$1++) {
	$2
}
endsnippet

snippet "(\S+)\.foe" "for each" ri
for(${1:auto} ${2:i} : `!p snip.rv = match.group(1)`){
	$3
}
endsnippet

snippet pii "pair int int" i
pair<int,int>
endsnippet

snippet vi "vector int" i
vector<int>
endsnippet

snippet mxu "max update" i
$1 = max($1,$2);$0
endsnippet

snippet mnu "min update" i
$1 = min($1,$2);$0
endsnippet

snippet usaco "usaco in and out files"
#ifndef LOCAL
freopen("$1.in","r",stdin);
freopen("$1.out","w",stdout);
#endif
endsnippet

